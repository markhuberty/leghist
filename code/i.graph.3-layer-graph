
        ### The following is a function to create a directed acyclic graph of committees, topics,
        ### and final/junk bins. 
        ### Line widths will represent amendment quantity, but actual amendments will not be
        ### represented. 
        ### The input this function takes is as follows:
#       A list (in the example below, called info), composed of:
#         
#         1) An a x 4 matrix A, where a is the number of amendments. Columns which denote index (1:a),
#                 committee number (1:c), topic number (1:t), and whether or
#                 not that amendment is junk or final bill material (0 or 1). e.g.
#                                      [,1] [,2] [,3] [,4]
#                                 [1,]    1    1    1    0
#                                 [2,]    2    1    1    1
#                                 [3,]    3    2    3    1
#                                 [4,]    4    3    1    0
#                                 [5,]    5    3    2    0
#                                 [6,]    6    1    3    0
#                        
# 
#         2) A vector, of length c+t+2 (# of committees + # of topics + 2 for the final/junk bins),
#            corresponding to the vertex label names. If not given, the label will default to the 
#            vertex index. If you do not want a label, "" returns a blank one.

 # library(igraph)

lay<-function(x,c,t){
         if (x<(c+1)) { cords<- c(x/(1+c),.2)
          } else {
             if (x>(c+t)) { cords<- c( (x-c-t)/3,.8)
                } else {
                        cords<- c( (x-c)/(1+t),.5)
                        }}
        return (cords)
                }

how.wide<-function(x,A){
                if (x[3]< num.arrows.to.topics+1){
                        width<- sum((x[1]==A[,2]) & (x[2]==A[,3]))
                } else {
                        width<- sum((x[1]==A[,3]) & (x[2]==A[,4]))
                } 
                }

my.graph<- function(info) {
# Graph of committees to topics to final/junk. Line widths represent # of amendments being represented.
        
# A will easily produce:info
#         A matrix whose rows correspond to each arrow. Its beginning and destination, where
#                 1,2,3,...,n correspond to the 1st,2nd,3rd,...nth vertex. Then graph(matrix)
#                 will be the object to graph. ( So e.g. one row may be c(2,9) denoting and arrow 
#                 from the 2nd to 9th vertex).
#    Along with line widths, colors, etc... 
        
        # Remember that the columns of A describe the index, committee number, topic number, 
        # and final success for each 1:a amendments.      
        
        A<-info[[1]]
        # a for # of amendments, c for # of committees, t for number of topics.
        a<-nrow(A)
        c<-length(unique(A[,2]))
        t<-length(unique(A[,3])) 
     
        # reindex. Note that igraph takes numbers starting at 0, not 1.
        A[,1:4]<-c( (A[,1]),
                    (A[,2]-1),
                    (A[,3]+c-1),
                    (A[,4]+c+t))
        
        
        arrows.mat<- rbind( unique( A[,2:3] ), unique(A[,3:4]) )
        num.arrows.to.topics<-nrow(unique( A[,2:3]))
        num.arrows.to.jf<-nrow(unique(A[,3:4]))
        num.arrows<-num.arrows.to.topics+num.arrows.to.jf
        # num.arrows = the number of arrows

        ### Layout
        # To create the layout, an nx2 matrix denoting the coordinates of each x vertices, you can use
        # a function or a matrix. Currently I use the following lines to create the matrix: (where there
        # are c+t+2 vertices, c of them committees, t of them topics, and 2 of them either final or junk bins.)
              
        ##  For the layout the matrix:
        x<-(c+t+2)
        y<-1:x
        lay.mat<-t(sapply(y,FUN=lay,c=c,t=t))
        ## So currently the graph is plotted on a (0,0),(1,1) screen, more or less.
 
        ### Edge Parameters. (Arrows)
        # 1) Edge width
        width<- apply(cbind(arrows.mat,1:num.arrows),1,how.wide,A=A)
        
         # 2) Arrow colors.
        # Note: in future, let the user define the colors, default to something like this if
        # user does not supply colors.
        # Problem. Multiple amendments may come from one committee going into the same topic. -->
        # Blend it? For now, it's just blue, yellow, and green. --> gradations in future.'

        colors<-c("cornflowerblue","darkgoldenrod1","chartreuse3")
        
       edge.color.idx<- c( (A[!duplicated(A[,2:3]),4]),
                    (A[!duplicated(A[,3:4]),4]) ) -c-t+1
            
         # see if the values in the row are the same. If not --> color = green for the
         # corresponding arrow, i.e. the first duplicate with value A[i,2:3].
        for ( i in which(duplicated(A[,2:3]))){
                # i.e. for each repeat arrow i:
            identical<- which (((A[i,2]==A[,2]) * (A[i,3]==A[,3]))==1)
            destinations<- A [ identical,4]
            if(length(unique(destinations))!=1) {
                    edge.color.idx[i]<- 3
                  }
                }
 
        edge.color<- colors[edge.color.idx]
        
        # Note: Vertex label colors?        
        
        ### Vertex Parameters
        # 1) Vertex label size.
        
                vertex.size<-rep(0,(c+t+2))
        
                for (i in 1:c){
                        vertex.size[i]<- sum(A[,2]==(i-1))
                        }
                for (i in (c+1):(c+t)) {
                        vertex.size[i]<- sum(A[,3]==(i-1))
                        }
                for (i in (c+t+1):(c+t+2)) {
                        vertex.size[i]<- sum(A[,4]==(i-1))
                        }
        v.size<- as.integer(floor(15*sqrt(vertex.size)))
        v.size2<-ceiling(10*sqrt(vertex.size))
        
        # 2) Vertex colors
        
        
        # 3) The vertex labels
        labels<-info[[2]] 
        
        ########
        
        # The actual object to be graphed:
        g.<-arrows.mat-min(arrows.mat)
        g..<-as.numeric(t(g.))
        g<-graph(g..)
        
        ########
        # Note 1. Need to make it so that vertex sizes, i.e. their areas, are truly
                # representative of their # of amendments. 
        # Note 2. Ideally, we'll want to allow the user to input any of these plot() inputs
        # manually, which this function will automatically create for them if they do not
        # supply it. e.g. edge.arrow.width is 1.5 now, but a user may want smaller or bigger
        # arrow heads (or variable ones) for some reason. To come.
                
        plot(g,
             layout=lay.mat,
             edge.arrow.width= .5,
             edge.width= 3*width,
             edge.color= edge.color,
             vertex.label= labels,
             vertex.shape= "rectangle",
             vertex.size= v.size,
             vertex.size2 = v.size2,
             vertex.label.dist= 0,
             vertex.label.font=.3,
             vertex.label.cex=.75,
                )
                        
        }
        # end my.graph function.


# Test 1.

#         A <- matrix(c(1:6,1,1,2,3,3,1,1,2,3,1,2,3,0,1,1,0,0,0),nrow=6)
#         colnames(A)<-c("idx","c #","t #","f/junk")
#         info<- list( A, c("c1","c2","c3","t1","t2","t3","junk","final"))
#
#         my.graph(info)

# Test 2.

#  initial<-c("orchid","bluejay","tulip","daisy","h.bird")
#  topics<-c("flowers","birds")
#  final<-c("junk","final")
#  initial.idx<-1:5
#  topic.destination.idx<-c(1,2,1,1,2)
#  destiny.idx<-c(0,0,0,1,1)
# 
#  A<-matrix(c(1:5,initial.idx,topic.destination.idx,destiny.idx),ncol=4)
#  names<-c(initial,topics,final)
#  info<-list(A,names)
#  
#  my.graph(info)
#  
#  
